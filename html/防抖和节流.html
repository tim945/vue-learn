<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>防抖和节流</title>
</head>
<body>
  <h3>防抖</h3>
  <div>触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间</div>

  <h4>思路</h4>
  <div>每次触发事件时都取消之前的延时调用方法</div>
  <div id="dou" style="height: 100px; width: 200px; overflow-y: scroll;">
    <p>防抖test1</p>
    <p>防抖test2</p>
    <p>防抖test3</p>
    <p>防抖test4</p>
    <p>防抖test5</p>
    <p>防抖test6</p>
    <p>防抖test7</p>
    <p>防抖test8</p>
    <p>防抖test9</p>
    <p>防抖test10</p>
    <p>防抖test1</p>
    <p>防抖test2</p>
    <p>防抖test3</p>
    <p>防抖test4</p>
    <p>防抖test5</p>
    <p>防抖test6</p>
    <p>防抖test7</p>
    <p>防抖test8</p>
    <p>防抖test9</p>
    <p>防抖test10</p>
  </div>
  <script>
  /* 防抖 */
  function dou(fn, wait, immediate=false) {
    var timer = null;
    return function () {
      console.log(timer)  // 只有首次执行时是 null
      if (! timer) {
        if (immediate) {  // 立刻执行一次
          fn.apply(this, arguments)
        }
        timer = setTimeout(() => {
          // console.log(this)//div
          fn.apply(this, arguments)//确保dou函数的this（上下文还是div）
        }, wait);
      } else {
        clearTimeout(timer)
        // time = setTimeout(function () {
        //  console.log(this)//window 
        //  fn.apply(this, arguments)//这样的话 this为window和直接 fn()调用是一样的效果，因为他们的this都是window
        // }, wait);
        timer = setTimeout(() => {
            // console.log(this)//div
            fn.apply(this, arguments)//确保dou函数的this（上下文还是div）
        }, wait);
      }        
    }
  }
  function demo() {
      console.log('防抖啦')
  }
  // 用句柄事件绑定调用dou事件，所以this为div节点对象
  document.querySelector('#dou').addEventListener('scroll', dou(demo, 1000, true));


  </script>


  <h3>节流</h3>
  <div>高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率</div>

  <h4>思路</h4>
  <div>每次触发事件时都判断当前是否有等待执行的延时函数</div>
  <p>
    <button id="throttle">节流Test</button>
  </p>
  <script>
  /* 节流 */
  function throttle(func, wait) {  
    var previous = 0;
    return function () {
        var now = +new Date();
        if (now - previous > wait) {  // 首次点击事件永执行， 后面在小于wait内不执行
            func.apply(this, arguments);
            previous = now;
        }
    }
  }
  function getUserAction() {
    console.log(`每秒1秒内打印一次`)
  }
  document.querySelector('#throttle').addEventListener('click', throttle(getUserAction, 1000))
  </script>

script start
async1 start
async2
async1 end
script end
promise1
promise2
setTimeout

</body>
</html>