<!--
 * @Author: tim
 * @Date: 2020-06-24 18:04:14
 * @LastEditors: tim
 * @LastEditTime: 2020-10-19 10:28:02
 * @Description: 
-->
1. 冒泡算法

``` js
var list = [5, 8, 6, 3, 5, 9, 1, 11, 7, 2, 4, 3]

for (var i=0; i<len-1; i++) {
	for (var j=0; j<len-1-i; j++) {
		if (list[j] > list[j+1]) {
			var temp = list[j]
			list[j] = list[j+1]
			list[j+1] = temp
		} 
	}	
}
```

2.二分查找(先排好序后再查找)
``` js
// 基本查找
var list = [1,3,4,6,7,8,10,13,14];
function getSearch(arr, target) {
	let start = 0
	let end = arr.length - 1

	while (start < end) {
		const mid = Math.floor(start + (end - start) / 2)
		if (arr[mid] == target) {
			return mid    // --> 注意点   找到直接返回
		} if (arr[mid] < target) {
			start = mid + 1
		} else {
			end = mid
		}
	}
	return arr[end] === target ? end:-1;    // 查找不到，返回-1 
}
	
// 左侧边界
let list = [5, 8, 6, 3, 5, 9, 1, 11, 7, 2, 4, 3]

function getOrder(arr, target) {
	let start = 0;
	let end = arr.length - 1;

	while (start < end) {
		const mid = Math.floor(start + (end - start) / 2)
		if (arr[mid] < target) {
			start = mid + 1;
		} else {
			end = mid;
		}		
	}
	return arr[end] === target ? end:-1;
}


```

3. 快速排序

时间复杂度：平均时间复杂度O(nlogn)，只有在特殊情况下会是O(n^2)，不过这种情况非常少

空间复杂度：辅助空间是logn，所以空间复杂度为O(logn)

``` js
let list = [5, 8, 6, 3, 5, 9, 1, 11, 7, 2, 4, 3]

function quickOrder(arr) {
	if (!arr || arr.length <=1) {
		return arr;
	}
	let temp = arr[0], left = [], right = [];
	for(let i=1, len=arr.length; i<len; i++) {
		let num = arr[i];
		if (num > temp) {
			right.push(num);
		} else {
			left.push(num);
		}
	}
	
	return quickOrder(left).concat(temp, quickOrder(right))
}


```

