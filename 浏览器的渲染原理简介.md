<!--
 * @Author: tim
 * @Date: 2020-10-14 16:41:43
 * @LastEditors: tim
 * @LastEditTime: 2020-10-14 17:17:09
 * @Description: https://coolshell.cn/articles/9666.html
-->
# 浏览器的渲染原理简介

## 浏览器工作大流程
![浏览器工作大流程](./static/img/browser/Render-Process-768x250.jpg)

从上面这个图中，我们可以看到那么几个事：


1. 浏览器会解析三个东西：

一个是HTML/SVG/XHTML，事实上，Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree。
CSS，解析CSS会产生CSS规则树。
Javascript，脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree.

2. 解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。注意：

Rendering Tree 渲染树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了。
CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element。也就是DOM结点。也就是所谓的Frame。
然后，计算每个Frame（也就是每个Element）的位置，这又叫layout和reflow过程。

3. 最后通过调用操作系统Native GUI的API绘制。

## DOM解析

## CSS解析

## 渲染

* Reflow 回流：
1. Initial。网页初始化的时候。
2. Incremental。一些Javascript在操作DOM Tree时。
3. Resize。其些元件的尺寸变了。
4. StyleChange。如果CSS的属性发生变化了。
5. Dirty。几个Incremental的reflow发生在同一个frame的子树上。

* Repaint 重绘

  屏幕的一部分要重画，比如某个CSS的背景色变了

## 减少reflow/repaint

* 尽可能少用 table 布局
* DOM 离线后再修改: 如先 隐藏或clone或使用documentFragment 对象在内存里操作DOM 
* 不要一条一条地修改DOM的样式。可以预先定义好css的class，然后修改DOM的className
* 尽可能的修改层级比较低的DOM
* 为动画的HTML元件使用fixed或absoult的position
